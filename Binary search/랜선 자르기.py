from sys import stdin

def binary_search(lan, start, end):
    while start <= end:
        mid = (start + end) // 2

        lines = 0
        for i in lan:
            lines += (i // mid)

        if lines >= n:
            start = mid + 1
            res = mid
        else:
            end = mid - 1

    return res


k, n = map(int, stdin.readline().split())
lan = list(int(stdin.readline()) for _ in range(k))

print(binary_search(lan, 1, max(lan)))

# 틀렸음
'''나의 해결 : 못 풀었다(너무 어렵게 생각했다)'''
'''해결 아이디어
1. 랜선의 길이를 기준으로 start 점은 1로 두고 end 점은 주어진 랜선의 최대값을 가지고 이분 탐색을 해 필요한 랜선의 길이를 만족하는 최대 mid 값을 출력하면 된다.
2. 필요한 랜선의 개수 보다 랜선이 많거나 같다면 start = mid + 1을 해주고 랜선이 적다면 end = mid - 1을 해준다
3. 필요한 랜선의 개수 보다 랜선이 많거나 같다는 가정하에 이전과 같은 상황을 비교해 봤을 때 갈수록 값이 커지므로 제일 마지막 값이 최대 값이다.
4. 반복이 계속 될수록 필요한 랜선의 개수와 만든 랜선의 개수가 같은 이유는 필요한 랜선의 개수가 만든 랜선의 개수보다 많은 경우에서 
한번 같은게 나오면 mid가 증가 하기때문에 같아질 수 밖에 없다.(mid가 증가하면 만든 랜선의 개수는 작아지는데 그것은 밑에 조건으로 가므로 같을때만 들어온다)
5. li = list(map(int, stdin.readlines()))를 통해 여러줄을 입력받을 수 있음'''

'''문제
1. 박성원이 캠프 때 쓸 N개의 랜선이 필요하다(오영석에게 부탁)
2. 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각
3. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다
4. 예를 들어 300짜리 랜선에서 140 짜리 랜선을 두 개 잘라내면 20은 버려야한다(이미 자른것은 붙일 수 없다)
5. 편의를 위해 랜선을 자르거나 만들 떄 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는
경우는 없다고 가정
6. 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정
7. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다, 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성'''