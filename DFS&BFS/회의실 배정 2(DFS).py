def dfs(n, val):
    global res

    if n >= N and val > res:
        res = val
        return

    for i in range(n, N):
        dfs(i + 2, val + data[i][2])


N = int(input())

data = []
for i in range(N):
    a, b, c = map(int, input().split())
    data.append([a, b, c])

res = 0
dfs(0, 0)
print(res)

# 틀렸음
'''나의 풀이 : 틀렸음'''
'''아이디어: 
1. 문제 자체를 이해하려고 하지 않고 그냥 넘어갔다. 나의 잘못이다
2. 예제에서는 시작시간이 차례대로 주어졌지만 입력에서는 차례대로 입력된다고 말하지 않았기 때문에 오름차순을 해준다
3. 바로 전 타임과 다음 타임은 겹치기 때문에 현재 타임을 기준으로 계산을 하게 된다면 다다음 타임 것부터 계산 해야한다.
4. 계산하려는 타임의 번호가 주어진 번호보다 크거나 더해온 val 값이 기존의 res 값보다 클 경우 함수에서 빠져나오고 res값을 초기화 한다
5. 1단계 2단계 3단계로 나눠서 더해진다 1단계에서는 1번쨰로 더해지는 수 2단계에서는 2번쨰로 더해지는 수 3단계에서는 3번쨰로 더해지는 수
(한개만 더하면 1단계에서 커버 가능 두개만 더하면 2단계에서 커버 가능)'''

'''문제
1. N개의 회의와 하나의 회의실을 선물로 받았다
2. 각 회의는 시작 시간, 끝나는 시간, 회의 인원이 주어지고 한 회의실에는 동시에 두 개 이상의 회의가 진행 x
3. 회의는 한번 시작되면 중간에 중단 x, 회의가 끝나는 것과 동시에 다음 회의가 시작'''

'''입력
1. 1 ≤ 회의 수 ≤ 25'''
